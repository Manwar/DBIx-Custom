.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Custom::Guide 3"
.TH DBIx::Custom::Guide 3 "2011-07-30" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
DBIx::Custom::Guide \- DBIx::Custom Guide
.SH "FEATURES"
.IX Header "FEATURES"
DBIx::Custom is the wrapper class of \s-1DBI\s0 to execute \s-1SQL\s0 easily.
This module have the following features.
.IP "* Execute \s-1INSERT\s0, \s-1UPDATE\s0, \s-1DELETE\s0, \s-1SELECT\s0 statement easily" 4
.IX Item "Execute INSERT, UPDATE, DELETE, SELECT statement easily"
.PD 0
.IP "* You can specify bind values by hash reference" 4
.IX Item "You can specify bind values by hash reference"
.IP "* Filtering by data type. and you can set filter to any column" 4
.IX Item "Filtering by data type. and you can set filter to any column"
.IP "* Creating where clause and order by clause flexibly" 4
.IX Item "Creating where clause and order by clause flexibly"
.IP "* Support model" 4
.IX Item "Support model"
.PD
.SH "GUIDE"
.IX Header "GUIDE"
.Sh "Connect to database"
.IX Subsection "Connect to database"
.Vb 7
\&    use DBIx::Custom;
\&    my $dbi = DBIx::Custom->connect(
\&        dsn => "dbi:mysql:database=bookshop",
\&        user => 'ken',
\&        password => '!LFKD%$&',
\&        dbi_option => {mysql_enable_utf8 => 1}
\&    );
.Ve
.PP
You can connect to database by \f(CW\*(C`connect\*(C'\fR method.
\&\f(CW\*(C`dsn\*(C'\fR is data source name, \f(CW\*(C`user\*(C'\fR is user name, \f(CW\*(C`password\*(C'\fR is password.
.PP
\&\f(CW\*(C`dbi_option\*(C'\fR is \s-1DBI\s0 option.
By default, the following option is set.
Exeption is thrown when fatal error occur and commit mode is auto commit.
.PP
.Vb 5
\&    {
\&        RaiseError  =>  1
\&        PrintError  =>  0
\&        AutoCommit  =>  1
\&    }
.Ve
.Sh "Execute query"
.IX Subsection "Execute query"
\fIInsert Statement : \f(CI\*(C`insert\*(C'\fI\fR
.IX Subsection "Insert Statement : insert"
.PP
If you want to execute insert statement, use \f(CW\*(C`insert\*(C'\fR method.
.PP
.Vb 1
\&    $dbi->insert({title => 'Perl', author => 'Ken'}, table  => 'book');
.Ve
.PP
First argument is insert row data, \f(CW\*(C`table\*(C'\fR  is table name.
.PP
\fIUpdate Statement : \f(CI\*(C`update\*(C'\fI\fR
.IX Subsection "Update Statement : update"
.PP
If you want to execute update stateimuse, use \f(CW\*(C`update\*(C'\fR method.
.PP
.Vb 5
\&    $dbi->update(
\&        {title => 'Perl', author => 'Ken'},
\&        table  => 'book', 
\&        where  => {id => 5}
\&    );
.Ve
.PP
First argument is update row data, \f(CW\*(C`table\*(C'\fR is table name, \f(CW\*(C`where\*(C'\fR is condition.
.PP
Note that you can't execute \f(CW\*(C`update\*(C'\fR method without \f(CW\*(C`where\*(C'\fR.
If you want to update all rows, use update_all.
.PP
.Vb 1
\&    $dbi->update_all({title => 'Perl', author => 'Ken'}, table  => 'book');
.Ve
.PP
\fIDelete Statement : \f(CI\*(C`delete\*(C'\fI\fR
.IX Subsection "Delete Statement : delete"
.PP
If you want to execute delete statement, use \f(CW\*(C`delete\*(C'\fR method.
.PP
.Vb 1
\&    $dbi->delete(table  => 'book', where  => {author => 'Ken'});
.Ve
.PP
\&\f(CW\*(C`table\*(C'\fR is table name, \f(CW\*(C`where\*(C'\fR is condition.
.PP
Note that you can't execute \f(CW\*(C`delete\*(C'\fR method without \f(CW\*(C`where\*(C'\fR.
If you want to delete all rows, use \f(CW\*(C`delete_all\*(C'\fR method.
.PP
.Vb 1
\&    $dbi->delete_all(table  => 'book');
.Ve
.PP
\fISelect Statement : \f(CI\*(C`select\*(C'\fI\fR
.IX Subsection "Select Statement : select"
.PP
If you want to execute select statement, use \f(CW\*(C`select\*(C'\fR method.
.PP
.Vb 1
\&    my $result = $dbi->select(table => 'book');
.Ve
.PP
Return value is DBIx::Custom::Result object.
You can fetch rows by \f(CW\*(C`fetch\*(C'\fR method.
.PP
.Vb 4
\&    while (my $row = $result->fetch) {
\&        my $title  = $row->[0];
\&        my $author = $row->[1];
\&    }
.Ve
.PP
See also \*(L"Fetch row\*(R" in Fetch row about DBIx::Custom::Result.
.PP
You can specify column names by \f(CW\*(C`column\*(C'\fR option
and condition by \f(CW\*(C`where\*(C'\fR option.
.PP
.Vb 5
\&    my $result = $dbi->select(
\&        table  => 'book',
\&        column => ['author',  'title'],
\&        where  => {author => 'Ken'}
\&    );
.Ve
.PP
You can specify join clause by \f(CW\*(C`join\*(C'\fR option.
.PP
.Vb 6
\&    my $result = $dbi->select(
\&        table  => 'book',
\&        column => ['company.name as company_name']
\&        where  => {'book.name' => 'Perl'},
\&        join   => ['left outer join company on book.company_id = company.id]
\&    );
.Ve
.PP
Note that join clause is joined only when \f(CW\*(C`where\*(C'\fR or \f(CW\*(C`column\*(C'\fR option contains table name,
such as book.name.
.PP
You can append statement to the end of whole statement by \f(CW\*(C`append\*(C'\fR option.
.PP
.Vb 5
\&    my $result = $dbi->select(
\&        table  => 'book',
\&        where  => {author => 'Ken'},
\&        append => 'for update',
\&    );
.Ve
.PP
\fI\f(CI\*(C`execute\*(C'\fI\fR
.IX Subsection "execute"
.PP
If you want to execute \s-1SQL\s0, use \f(CW\*(C`execute\*(C'\fR method.
.PP
.Vb 1
\&    $dbi->execute("select * from book;");
.Ve
.PP
You can specify named placeholder.
.PP
.Vb 4
\&    $dbi->execute(
\&        "select * from book title = :title and author = :author;"
\&        {title => 'Perl', author => 'Ken'}
\&    );
.Ve
.PP
:title and :author is named placeholder, which is replaced to placeholers.
.PP
.Vb 1
\&    select * from book title = ? and author = ?;
.Ve
.PP
\fI\f(CI\*(C`dbh\*(C'\fI\fR
.IX Subsection "dbh"
.PP
.Vb 1
\&    my $dbh = $dbi->dbh;
.Ve
.PP
Get get database handle object of \s-1DBI\s0.
.PP
\fI\f(CI\*(C`DBI\*(C'\fI methods\fR
.IX Subsection "DBI methods"
.PP
.Vb 2
\&    $dbi->do(...);
\&    $dbi->begin_work;
.Ve
.PP
You can call all methods of \s-1DBI\s0 from DBIx::Custom object.
.Sh "Fetch Rows"
.IX Subsection "Fetch Rows"
\&\f(CW\*(C`select\*(C'\fR method return value is DBIx::Custom::Result object.
You can fetch a row or rows by various methods.
.PP
\fIFetch a row (array) : \f(CI\*(C`fetch\*(C'\fI\fR
.IX Subsection "Fetch a row (array) : fetch"
.PP
.Vb 1
\&    my $row = $result->fetch;
.Ve
.PP
\&\f(CW\*(C`fetch\*(C'\fR method fetch a row and put it into array reference.
You can continue to fetch 
.PP
.Vb 4
\&    while (my $row = $result->fetch) {
\&        my $title  = $row->[0];
\&        my $author = $row->[1];
\&    }
.Ve
.PP
\fIFetch only first row (array) : \f(CI\*(C`fetch_first\*(C'\fI\fR
.IX Subsection "Fetch only first row (array) : fetch_first"
.PP
.Vb 1
\&    my $row = $result->fetch_first;
.Ve
.PP
\&\f(CW\*(C`fetch_first\*(C'\fR fetch a only first row and finish statment handle,
and put it into array refrence.
.PP
\fIFetch all rows (array) : \f(CI\*(C`fetch_all\*(C'\fI\fR
.IX Subsection "Fetch all rows (array) : fetch_all"
.PP
.Vb 1
\&    my $rows = $result->fetch_all;
.Ve
.PP
\&\f(CW\*(C`fetch_all\*(C'\fR fetch all rows and put them into array of array reference.
.PP
\fIFetch a row (hash) : \f(CI\*(C`fetch_hash\*(C'\fI\fR
.IX Subsection "Fetch a row (hash) : fetch_hash"
.PP
.Vb 1
\&    my $row = $result->fetch_hash;
.Ve
.PP
\&\f(CW\*(C`fetch_hash\*(C'\fR fetch a row and put it into hash reference.
You can fetch a row while row exists.
.PP
.Vb 4
\&    while (my $row = $result->fetch_hash) {
\&        my $title  = $row->{title};
\&        my $author = $row->{author};
\&    }
.Ve
.PP
\fIFetch only a first row (hash) : \f(CI\*(C`fetch_hash_first\*(C'\fI\fR
.IX Subsection "Fetch only a first row (hash) : fetch_hash_first"
.PP
.Vb 1
\&    my $row = $result->fetch_hash_first;
.Ve
.PP
\&\f(CW\*(C`fetch_hash_first\*(C'\fR fetch only a first row and finish statement handle,
and put them into hash refrence.
.PP
\&\f(CW\*(C`one\*(C'\fR is \f(CW\*(C`fetch_hash_first\*(C'\fR synonym to save word typing.
.PP
.Vb 1
\&    my $row = $result->one;
.Ve
.PP
\fIFetch all rows (hash) : \f(CI\*(C`fetch_hash_all\*(C'\fI\fR
.IX Subsection "Fetch all rows (hash) : fetch_hash_all"
.PP
.Vb 1
\&    my $rows = $result->fetch_hash_all;
.Ve
.PP
\&\f(CW\*(C`fetch_hash_all\*(C'\fR fetch all rows and put them into array of hash reference.
.PP
\fIStatement Handle : \f(CI\*(C`sth\*(C'\fI\fR
.IX Subsection "Statement Handle : sth"
.PP
.Vb 1
\&    my $sth = $result->sth;
.Ve
.PP
If you want to get statment handle, use <sth> method.
.Sh "Named placeholder"
.IX Subsection "Named placeholder"
\fIBasic of Parameter\fR
.IX Subsection "Basic of Parameter"
.PP
You can embedd named placeholder into \s-1SQL\s0.
.PP
.Vb 1
\&    select * from book where title = :title and author like :author;
.Ve
.PP
:title and :author is named placeholder
.PP
Named placeholder is replaced by place holder.
.PP
.Vb 1
\&    select * from book where title = ? and author like ?;
.Ve
.PP
use \f(CW\*(C`execute\*(C'\fR to execute \s-1SQL\s0.
.PP
.Vb 2
\&    my $sql = "select * from book where title = :title and author like :author;"
\&    $dbi->execute($sql, {title => 'Perl', author => '%Ken%'});
.Ve
.PP
You can specify \f(CW\*(C`filter\*(C'\fR at \f(CW\*(C`execute\*(C'\fR.
.PP
.Vb 2
\&    $dbi->execute($sql, {title => 'Perl', author => '%Ken%'}
\&                  filter => {title => 'to_something');
.Ve
.PP
\fIManipulate same name's columns\fR
.IX Subsection "Manipulate same name's columns"
.PP
It is ok if there are same name's columns.
Let's think two date comparison.
.PP
.Vb 1
\&    my $sql = "select * from table where date > :date and date < :date;";
.Ve
.PP
In this case, You specify parameter values as array reference.
.PP
.Vb 1
\&    my $dbi->execute($sql, {date => ['2010-10-01', '2012-02-10']});
.Ve
.Sh "Create where clause"
.IX Subsection "Create where clause"
\fIDinamically create where clause : where\fR
.IX Subsection "Dinamically create where clause : where"
.PP
You want to search multiple conditions in many times.
Let's think the following three cases.
.PP
Case1: Search only \f(CW\*(C`title\*(C'\fR
.PP
.Vb 1
\&    where title = :title
.Ve
.PP
Case2: Search only \f(CW\*(C`author\*(C'\fR
.PP
.Vb 1
\&    where author = :author
.Ve
.PP
Case3: Search \f(CW\*(C`title\*(C'\fR and \f(CW\*(C`author\*(C'\fR
.PP
.Vb 1
\&    where title = :title and author = :author
.Ve
.PP
DBIx::Custom support dinamic where clause creating.
At first, create DBIx::Custom::Where object by \f(CW\*(C`where\*(C'\fR.
.PP
.Vb 1
\&    my $where = $dbi->where;
.Ve
.PP
Set clause by \f(CW\*(C`clause\*(C'\fR
.PP
.Vb 3
\&    $where->clause(
\&        ['and', 'title = :title, 'author = :author']
\&    );
.Ve
.PP
\&\f(CW\*(C`clause\*(C'\fR is the following format.
.PP
.Vb 1
\&    ['or' or 'and', PART1, PART1, PART1]
.Ve
.PP
First argument is 'or' or 'and'.
Later than first argument are part which contains named placeholder.
.PP
You can write more complex format.
.PP
.Vb 4
\&    ['and', 
\&      'title = :title', 
\&      ['or', 'author = :author', 'date like :date']
\&    ]
.Ve
.PP
This mean \*(L"title = :title and ( author = :author or date like :date )\*(R".
.PP
After setting \f(CW\*(C`clause\*(C'\fR, set \f(CW\*(C`param\*(C'\fR.
.PP
.Vb 1
\&    $where->param({title => 'Perl'});
.Ve
.PP
In this example, parameter contains only title.
.PP
If you execute \f(CW\*(C`string_to\*(C'\fR, you can get where clause
which contain only named placeholder.
.PP
.Vb 1
\&    my $where_clause = $where->to_string;
.Ve
.PP
Parameter name is only title, the following where clause is created.
.PP
.Vb 1
\&    where title = :title
.Ve
.PP
You can also create where clause by stringification.
.PP
.Vb 1
\&    my $where_clause = "$where";
.Ve
.PP
This is useful to embbed it into \s-1SQL\s0. 
.PP
\fIIn case where clause contains same name columns\fR
.IX Subsection "In case where clause contains same name columns"
.PP
Even if same name parameters exists, you can create where clause.
Let's think that there are starting date and ending date.
.PP
.Vb 1
\&    my $param = {start_date => '2010-11-15', end_date => '2011-11-21'};
.Ve
.PP
In this case, you set parameter value as array reference.
.PP
.Vb 1
\&    my $p = {date => ['2010-11-15', '2011-11-21']};
.Ve
.PP
You can embbed these values into same name parameters.
.PP
.Vb 4
\&    $where->clause(
\&        ['and', 'date > :date', 'date < :date']
\&    );
\&    $where->param($p);
.Ve
.PP
If starting date isn't exists, create the following parameter.
.PP
.Vb 1
\&    my $p = {date => [$dbi->not_exists, '2011-11-21']};
.Ve
.PP
You can get DBIx::Custom::NotExists object by \f(CW\*(C`not_exists\*(C'\fR
This mean correnspondinf value isn't exists.
.PP
If ending date isn't exists, create the following parameter.
.PP
.Vb 1
\&    my $p = {date => ['2010-11-15']};
.Ve
.PP
If both date isn't exists, create the following parameter.
.PP
.Vb 1
\&    my $p = {date => []};
.Ve
.PP
This logic is a little difficut. See the following ones.
.PP
.Vb 5
\&    my @date;
\&    push @date, exists $param->{start_date} ? $param->{start_date}
\&                                            : $dbi->not_exists;
\&    push @date, $param->{end_date} if exists $param->{end_date};
\&    my $p = {date => \e@date};
.Ve
.PP
\fIWith \f(CI\*(C`select\*(C'\fI\fR
.IX Subsection "With select"
.PP
You can pass DBIx::Custom::Where object to \f(CW\*(C`where\*(C'\fR of \f(CW\*(C`select\*(C'\fR.
.PP
.Vb 4
\&    my $where = $dbi->where;
\&    $where->clause(['and', 'title = :title', 'author = :author']);
\&    $where->param({title => 'Perl'});
\&    my $result = $dbi->select(table => 'book', where => $where);
.Ve
.PP
You can also pass it to \f(CW\*(C`where\*(C'\fR of \f(CW\*(C`update\*(C'\fRA\f(CW\*(C`delete\*(C'\fR
.PP
\fIWith \f(CI\*(C`execute\*(C'\fI\fR
.IX Subsection "With execute"
.PP
DBIx::Custom::Where object is embedded into \s-1SQL\s0.
.PP
.Vb 3
\&    my $where = $dbi->where;
\&    $where->clause(['and', 'title = :title', 'author = :author']);
\&    $where->param({title => 'Perl'});
.Ve
.PP
.Vb 4
\&    my $sql = <<"EOS";
\&    select * from book;
\&    $where
\&    EOS
.Ve
.PP
.Vb 1
\&    $dbi->execute($sql, $param, table => 'book');
.Ve
.Sh "Filtering"
.IX Subsection "Filtering"
\fIRegister filter : \f(CI\*(C`register_filter\*(C'\fI\fR
.IX Subsection "Register filter : register_filter"
.PP
If you want to register filter, use \f(CW\*(C`register_filter\*(C'\fR.
.PP
.Vb 6
\&    $dbi->register_filter(
\&        # Time::Piece object to DATE format
\&        tp_to_date => sub {
\&            my $date = shift;
\&            return $tp->strftime('%Y-%m-%d');
\&        },
.Ve
.PP
.Vb 6
\&        # DATE to Time::Piece object
\&        date_to_tp => sub {
\&            my $date = shift;
\&            return Time::Piece->strptime($date, '%Y-%m-%d');
\&        },
\&    );
.Ve
.PP
\fIFilter before sending data into database : \f(CI\*(C`filter\*(C'\fI option\fR
.IX Subsection "Filter before sending data into database : filter option"
.PP
If you filter sending data, use \f(CW\*(C`filter\*(C'\fR option.
.PP
.Vb 5
\&    $dbi->execute(
\&        'insert into book (date) values (:date)',
\&        {date => $tp},
\&        filter => {date => 'tp_to_date'}
\&    );
.Ve
.PP
You can use \f(CW\*(C`filter\*(C'\fR option in \f(CW\*(C`insert\*(C'\fR, \f(CW\*(C`update\*(C'\fR, \f(CW\*(C`delete\*(C'\fR, \f(CW\*(C`select\*(C'\fR method.
.PP
.Vb 5
\&    $dbi->insert(
\&        {date => $tp},
\&        table => 'book',
\&        filter => {date => 'tp_to_date'}
\&    );
.Ve
.PP
\fIFilter after fetching data from database.\fR
.IX Subsection "Filter after fetching data from database."
.PP
If you filter fetch data, use DBIx::Custom::Result's \f(CW\*(C`filter\*(C'\fR method.
.PP
.Vb 3
\&    my $result = $dbi->select(column => 'date', table => 'book');
\&    $result->filter(date => 'date_to_tp');
\&    my $row = $result->one;
.Ve
.Sh "7. Model"
.IX Subsection "7. Model"
\fIModel\fR
.IX Subsection "Model"
.PP
you can define model extending DBIx::Custom::Model
to improve source code view.
.PP
At first, you create basic model class extending <DBIx::Custom::Model>.
Each DBIx::Custom class inherit Object::Simple.
so you can inherit the following way.
.PP
.Vb 2
\&    package MyModel;
\&    use DBIx::Custom::Model -base;
.Ve
.PP
Next, you create each model classes.
.PP
MyModel::book
.PP
.Vb 2
\&    package MyModel::book;
\&    use MyModel -base;
.Ve
.PP
.Vb 2
\&    sub insert { ... }
\&    sub list { ... }
.Ve
.PP
MyModel::company
.PP
.Vb 2
\&    package MyModel::company;
\&    use MyModel -base;
.Ve
.PP
.Vb 2
\&    sub insert { ... }
\&    sub list { ... }
.Ve
.PP
The follwoing modules location is needed.
.PP
.Vb 3
\&    MyModel.pm
\&    MyModel / book.pm
\&            / company.pm
.Ve
.PP
You can include these models by \f(CW\*(C`include_model\*(C'\fR
.PP
.Vb 1
\&    $dbi->include_model('MyModel');
.Ve
.PP
First argument is name space of model.
.PP
You can use model like this.
.PP
.Vb 1
\&    my $result = $dbi->model('book')->list;
.Ve
.PP
In mode, You can use such as methods,
\&\f(CW\*(C`insert\*(C'\fR, \f(CW\*(C`update\*(C'\fR, \f(CW\*(C`update_all\*(C'\fR,
\&\f(CW\*(C`delete\*(C'\fR, \f(CW\*(C`delete_all\*(C'\fR, \f(CW\*(C`select\*(C'\fR
without \f(CW\*(C`table\*(C'\fR option.
.PP
.Vb 1
\&    $dbi->model('book')->insert($param);
.Ve
.PP
Model is DBIx::Custom::Model.
.PP
If you need table nameAyou can get it by \f(CW\*(C`table\*(C'\fR.
.PP
.Vb 1
\&    my $table = $model->table;
.Ve
.PP
You can get DBIx::Custom.
.PP
.Vb 1
\&    my $dbi = $model->dbi;
.Ve
.PP
You can also call all methods of DBIx::Custom and \s-1DBI\s0. 
.PP
.Vb 2
\&    # DBIx::Custom method
\&    $model->execute($sql);
.Ve
.PP
.Vb 3
\&    # DBI method
\&    $model->begin_work;
\&    $model->commit;
.Ve
.PP
If you want to get all models, you can get them by keys of \f(CW\*(C`models\*(C'\fR.
.PP
.Vb 1
\&    my @models = keys %{$self->models};
.Ve
.PP
You can set primary key to model.
.PP
.Vb 1
\&   $model->primary_key(['id', 'number_id']);
.Ve
.PP
Primary key is used by \f(CW\*(C`insert\*(C'\fR, \f(CW\*(C`update\*(C'\fR, \f(CW\*(C`delete\*(C'\fR,
and \f(CW\*(C`select\*(C'\fR methods.
.PP
You can set column names
.PP
.Vb 1
\&    $model->columns(['id', 'number_id']);
.Ve
.PP
Column names is automarically set by \f(CW\*(C`setup_model\*(C'\fR.
This method is needed to be call after \f(CW\*(C`include_model\*(C'\fR.
.PP
.Vb 1
\&    $dbi->setup_model;
.Ve
.PP
You can set \f(CW\*(C`join\*(C'\fR
.PP
.Vb 1
\&    $model->join(['left outer join company on book.company_id = company.id']);
.Ve
.PP
\&\f(CW\*(C`join\*(C'\fR is used by \f(CW\*(C`select\*(C'\fR method.
.Sh "Create column clause automatically : mycolumn, column"
.IX Subsection "Create column clause automatically : mycolumn, column"
To create column clause automatically, use \f(CW\*(C`mycolumn\*(C'\fR.
Valude of \f(CW\*(C`table\*(C'\fR and \f(CW\*(C`columns\*(C'\fR is used.
.PP
.Vb 1
\&    my $mycolumns = $model->mycolumn;
.Ve
.PP
If \f(CW\*(C`table\*(C'\fR is 'book'A\f(CW\*(C`column\*(C'\fR is ['id', 'name'],
the following clause is created.
.PP
.Vb 1
\&    book.id as id, book.name as name
.Ve
.PP
These column name is for removing column name ambiguities.
.PP
You can create column clause from columns of other table.
.PP
.Vb 1
\&    my $columns = $model->column('company');
.Ve
.PP
If \f(CW\*(C`table\*(C'\fR is \*(L"company\*(R", \f(CW\*(C`column\*(C'\fR return ['id', 'name'],
the following clause is created.
.PP
.Vb 1
\&    company.id as "company.id", company.name as "company.name"
.Ve
.Sh "Model Examples"
.IX Subsection "Model Examples"
Model examples
.PP
.Vb 2
\&    package MyDBI;
\&    use DBIx::Custom -base;
.Ve
.PP
.Vb 2
\&    sub connect {
\&        my $self = shift->SUPER::connect(@_);
.Ve
.PP
.Vb 7
\&        $self->include_model(
\&            MyModel => [
\&                'book',
\&                'company'
\&            ]
\&        );
\&    }
.Ve
.PP
.Vb 2
\&    package MyModel::book;
\&    use DBIx::Custom::Model -base;
.Ve
.PP
.Vb 1
\&    has primary_key => sub { ['id'] };
.Ve
.PP
.Vb 2
\&    sub insert { ... }
\&    sub list { ... }
.Ve
.PP
.Vb 2
\&    package MyModel::company;
\&    use DBIx::Custom::Model -base;
.Ve
.PP
.Vb 1
\&    has primary_key => sub { ['id'] };
.Ve
.PP
.Vb 2
\&    sub insert { ... }
\&    sub list { ... }
.Ve
