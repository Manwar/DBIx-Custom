.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Custom 3"
.TH DBIx::Custom 3 "2009-11-16" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
DBIx::Custom \- Customizable simple DBI
.SH "VERSION"
.IX Header "VERSION"
Version 0.0501
.SH "CAUTION"
.IX Header "CAUTION"
This module is now experimental stage.
.PP
I want you to try this module
because I want this module stable, and not to damage your \s-1DB\s0 data by this module bug.
.PP
Please tell me bug if you find
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  my $dbi = DBIx::Custom->new;
.Ve
.PP
.Vb 2
\&  my $query = $dbi->create_query($template);
\&  $dbi->execute($query);
.Ve
.SH "CLASS-OBJECT ACCESSORS"
.IX Header "CLASS-OBJECT ACCESSORS"
.Sh "user"
.IX Subsection "user"
.Vb 3
\&    # Set and get database user name
\&    $self = $dbi->user($user);
\&    $user = $dbi->user;
.Ve
.PP
.Vb 2
\&    # Sample
\&    $dbi->user('taro');
.Ve
.Sh "password"
.IX Subsection "password"
.Vb 3
\&    # Set and get database password
\&    $self     = $dbi->password($password);
\&    $password = $dbi->password;
.Ve
.PP
.Vb 2
\&    # Sample
\&    $dbi->password('lkj&le`@s');
.Ve
.Sh "data_source"
.IX Subsection "data_source"
.Vb 3
\&    # Set and get database data source
\&    $self        = $dbi->data_source($data_soruce);
\&    $data_source = $dbi->data_source;
.Ve
.PP
.Vb 2
\&    # Sample(SQLite)
\&    $dbi->data_source(dbi:SQLite:dbname=$database);
.Ve
.PP
.Vb 2
\&    # Sample(MySQL);
\&    $dbi->data_source("dbi:mysql:dbname=$database");
.Ve
.PP
.Vb 2
\&    # Sample(PostgreSQL)
\&    $dbi->data_source("dbi:Pg:dbname=$database");
.Ve
.Sh "database"
.IX Subsection "database"
.Vb 3
\&    # Set and get database name
\&    $self     = $dbi->database($database);
\&    $database = $dbi->database;
.Ve
.PP
This method will be used in subclass connect method.
.Sh "dbi_options"
.IX Subsection "dbi_options"
.Vb 3
\&    # Set and get DBI option
\&    $self       = $dbi->dbi_options({$options => $value, ...});
\&    $dbi_options = $dbi->dbi_options;
.Ve
.PP
.Vb 2
\&    # Sample
\&    $dbi->dbi_options({PrintError => 0, RaiseError => 1});
.Ve
.PP
dbi_options is used when you connect database by using connect.
.Sh "prepare"
.IX Subsection "prepare"
.Vb 1
\&    $sth = $dbi->prepare($sql);
.Ve
.PP
This method is same as DBI::prepare
.Sh "do"
.IX Subsection "do"
.Vb 1
\&    $dbi->do($sql, @bind_values);
.Ve
.PP
This method is same as DBI::do
.Sh "sql_template"
.IX Subsection "sql_template"
.Vb 3
\&    # Set and get SQL::Template object
\&    $self         = $dbi->sql_template($sql_template);
\&    $sql_template = $dbi->sql_template;
.Ve
.PP
.Vb 2
\&    # Sample
\&    $dbi->sql_template(DBI::Cutom::SQL::Template->new);
.Ve
.Sh "filters"
.IX Subsection "filters"
.Vb 3
\&    # Set and get filters
\&    $self    = $dbi->filters($filters);
\&    $filters = $dbi->filters;
.Ve
.Sh "formats"
.IX Subsection "formats"
.Vb 3
\&    # Set and get formats
\&    $self    = $dbi->formats($formats);
\&    $formats = $dbi->formats;
.Ve
.Sh "bind_filter"
.IX Subsection "bind_filter"
.Vb 3
\&    # Set and get binding filter
\&    $self        = $dbi->bind_filter($bind_filter);
\&    $bind_filter = $dbi->bind_filter
.Ve
.PP
.Vb 2
\&    # Sample
\&    $dbi->bind_filter($self->filters->{default_bind_filter});
.Ve
.PP
you can get \s-1DBI\s0 database handle if you need.
.Sh "fetch_filter"
.IX Subsection "fetch_filter"
.Vb 3
\&    # Set and get Fetch filter
\&    $self         = $dbi->fetch_filter($fetch_filter);
\&    $fetch_filter = $dbi->fetch_filter;
.Ve
.PP
.Vb 2
\&    # Sample
\&    $dbi->fetch_filter($self->filters->{default_fetch_filter});
.Ve
.Sh "no_bind_filters"
.IX Subsection "no_bind_filters"
.Vb 3
\&    # Set and get no filter keys when binding
\&    $self            = $dbi->no_bind_filters($no_bind_filters);
\&    $no_bind_filters = $dbi->no_bind_filters;
.Ve
.Sh "no_fetch_filters"
.IX Subsection "no_fetch_filters"
.Vb 3
\&    # Set and get no filter keys when fetching
\&    $self             = $dbi->no_fetch_filters($no_fetch_filters);
\&    $no_fetch_filters = $dbi->no_fetch_filters;
.Ve
.Sh "result_class"
.IX Subsection "result_class"
.Vb 3
\&    # Set and get resultset class
\&    $self         = $dbi->result_class($result_class);
\&    $result_class = $dbi->result_class;
.Ve
.PP
.Vb 2
\&    # Sample
\&    $dbi->result_class('DBIx::Custom::Result');
.Ve
.Sh "dbh"
.IX Subsection "dbh"
.Vb 2
\&    # Get database handle
\&    $dbh = $self->dbh;
.Ve
.SH "METHODS"
.IX Header "METHODS"
.Sh "connect"
.IX Subsection "connect"
.Vb 2
\&    # Connect to database
\&    $self = $dbi->connect;
.Ve
.PP
.Vb 4
\&    # Sample
\&    $dbi = DBIx::Custom->new(user => 'taro', password => 'lji8(', 
\&                            data_soruce => "dbi:mysql:dbname=$database");
\&    $dbi->connect;
.Ve
.Sh "disconnect"
.IX Subsection "disconnect"
.Vb 2
\&    # Disconnect database
\&    $dbi->disconnect;
.Ve
.PP
If database is already disconnected, this method do noting.
.Sh "reconnect"
.IX Subsection "reconnect"
.Vb 2
\&    # Reconnect
\&    $dbi->reconnect;
.Ve
.Sh "connected"
.IX Subsection "connected"
.Vb 2
\&    # Check connected
\&    $dbi->connected
.Ve
.Sh "filter_off"
.IX Subsection "filter_off"
.Vb 2
\&    # bind_filter and fitch_filter off
\&    $self->filter_off;
.Ve
.PP
This is equeal to
.PP
.Vb 2
\&    $self->bind_filter(undef);
\&    $self->fetch_filter(undef);
.Ve
.Sh "add_filter"
.IX Subsection "add_filter"
.Vb 3
\&    # Add filter (hash ref or hash can be recieve)
\&    $self = $dbi->add_filter({$filter_name => $filter, ...});
\&    $self = $dbi->add_filter($filetr_name => $filter, ...);
.Ve
.PP
.Vb 19
\&    # Sample
\&    $dbi->add_filter(
\&        decode_utf8 => sub {
\&            my ($key, $value, $table, $column) = @_;
\&            return Encode::decode('UTF-8', $value);
\&        },
\&        datetime_to_string => sub {
\&            my ($key, $value, $table, $column) = @_;
\&            return $value->strftime('%Y-%m-%d %H:%M:%S')
\&        },
\&        default_bind_filter => sub {
\&            my ($key, $value, $table, $column) = @_;
\&            if (ref $value eq 'Time::Piece') {
\&                return $dbi->filters->{datetime_to_string}->($value);
\&            }
\&            else {
\&                return $dbi->filters->{decode_utf8}->($value);
\&            }
\&        },
.Ve
.PP
.Vb 18
\&        encode_utf8 => sub {
\&            my ($key, $value) = @_;
\&            return Encode::encode('UTF-8', $value);
\&        },
\&        string_to_datetime => sub {
\&            my ($key, $value) = @_;
\&            return DateTime::Format::MySQL->parse_datetime($value);
\&        },
\&        default_fetch_filter => sub {
\&            my ($key, $value, $type, $sth, $i) = @_;
\&            if ($type eq 'DATETIME') {
\&                return $dbi->filters->{string_to_datetime}->($value);
\&            }
\&            else {
\&                return $dbi->filters->{encode_utf8}->($value);
\&            }
\&        }
\&    );
.Ve
.PP
add_filter add filter to filters
.Sh "add_format"
.IX Subsection "add_format"
.Vb 1
\&    $dbi->add_format(date => '%Y:%m:%d');
.Ve
.Sh "create_query"
.IX Subsection "create_query"
.Vb 2
\&    # Create Query object from SQL template
\&    my $query = $dbi->create_query($template);
.Ve
.Sh "execute"
.IX Subsection "execute"
.Vb 3
\&    # Parse SQL template and execute SQL
\&    $result = $dbi->query($query, $params);
\&    $result = $dbi->query($template, $params); # Shorcut
.Ve
.PP
.Vb 3
\&    # Sample
\&    $result = $dbi->query("select * from authors where {= name} and {= age}", 
\&                          {author => 'taro', age => 19});
.Ve
.PP
.Vb 3
\&    while (my @row = $result->fetch) {
\&        # do something
\&    }
.Ve
.PP
See also DBIx::Custom::SQL::Template
.Sh "run_transaction"
.IX Subsection "run_transaction"
.Vb 4
\&    # Run transaction
\&    $dbi->run_transaction(sub {
\&        # do something
\&    });
.Ve
.PP
If transaction is success, commit is execute. 
If tranzation is died, rollback is execute.
.Sh "insert"
.IX Subsection "insert"
.Vb 2
\&    # Insert
\&    $dbi->insert($table, $insert_values);
.Ve
.PP
.Vb 2
\&    # Sample
\&    $dbi->insert('books', {title => 'Perl', author => 'Taro'});
.Ve
.Sh "update"
.IX Subsection "update"
.Vb 2
\&    # Update
\&    $dbi->update($table, $update_values, $where);
.Ve
.PP
.Vb 2
\&    # Sample
\&    $dbi->update('books', {title => 'Perl', author => 'Taro'}, {id => 5});
.Ve
.Sh "update_all"
.IX Subsection "update_all"
.Vb 2
\&    # Update all rows
\&    $dbi->update($table, $updat_values);
.Ve
.Sh "delete"
.IX Subsection "delete"
.Vb 2
\&    # Delete
\&    $dbi->delete($table, $where);
.Ve
.PP
.Vb 2
\&    # Sample
\&    $dbi->delete('Books', {id => 5});
.Ve
.Sh "delete_all"
.IX Subsection "delete_all"
.Vb 2
\&    # Delete all rows
\&    $dbi->delete_all($table);
.Ve
.Sh "last_insert_id"
.IX Subsection "last_insert_id"
.Vb 2
\&    # Get last insert id
\&    $last_insert_id = $dbi->last_insert_id;
.Ve
.PP
This method is same as \s-1DBI\s0 last_insert_id;
.Sh "select"
.IX Subsection "select"
.Vb 8
\&    # Select
\&    $dbi->select(
\&        $table,                # must be string or array;
\&        [@$columns],           # must be array reference. this is optional
\&        {%$where_params},      # must be hash reference.  this is optional
\&        $append_statement,     # must be string.          this is optional
\&        $query_edit_callback   # must be code reference.  this is optional
\&    );
.Ve
.PP
.Vb 13
\&    # Sample
\&    $dbi->select(
\&        'Books',
\&        ['title', 'author'],
\&        {id => 1},
\&        "for update",
\&        sub {
\&            my $query = shift;
\&            $query->bind_filter(sub {
\&                # ...
\&            });
\&        }
\&    );
.Ve
.PP
.Vb 7
\&    # The way to join multi tables
\&    $dbi->select(
\&        ['table1', 'table2'],
\&        ['table1.id as table1_id', 'title'],
\&        {table1.id => 1},
\&        "where table1.id = table2.id",
\&    );
.Ve
.SH "Class Accessors"
.IX Header "Class Accessors"
.Sh "query_cache_max"
.IX Subsection "query_cache_max"
.Vb 3
\&    # Max query cache count
\&    $class           = $class->query_cache_max($query_cache_max);
\&    $query_cache_max = $class->query_cache_max;
.Ve
.PP
.Vb 2
\&    # Sample
\&    DBIx::Custom->query_cache_max(50);
.Ve
.SH "CAUTION"
.IX Header "CAUTION"
DBIx::Custom have \s-1DIB\s0 object internal.
This module is work well in the following \s-1DBI\s0 condition.
.PP
.Vb 2
\&    1. AutoCommit is true
\&    2. RaiseError is true
.Ve
.PP
By default, Both AutoCommit and RaiseError is true.
You must not change these mode not to damage your data.
.PP
If you change these mode, 
you cannot get correct error message, 
or run_transaction may fail.
.SH "AUTHOR"
.IX Header "AUTHOR"
Yuki Kimoto, \f(CW\*(C`<kimoto.yuki at gmail.com>\*(C'\fR
.PP
Github <http://github.com/yuki\-kimoto>
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2009 Yuki Kimoto, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
